<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20090628091852.6030"><vh>Startup</vh>
<v t="ville.20090627211608.5783"><vh>@chapters</vh></v>
<v t="ekr.20090628091852.6031"><vh>@settings</vh>
<v t="ekr.20090628091852.8471"><vh>@string target_language = rest</vh></v>
<v t="ekr.20090628092246.4267"><vh>@int page_width = 60</vh></v>
</v>
<v t="ekr.20090628092604.1829"><vh>change log</vh></v>
</v>
<v t="ville.20090627211608.5782"><vh>Welcome to Leo!</vh></v>
<v t="ville.20090627211608.5784"><vh>Tree manipulation basics</vh></v>
<v t="ville.20090630234425.12394"><vh>Programming</vh>
<v t="ville.20090627211608.10118"><vh>External files</vh>
<v t="ville.20090627211608.10116"><vh>Thin nodes (explanation &amp; exercise)</vh>
<v t="ville.20090627211608.10119"><vh>@path ~</vh>
<v t="ville.20090627211608.10117"><vh>@@thin myfile_thin.py</vh>
<v t="ville.20090627211608.10120"><vh>imports &amp; setup routines</vh>
<v t="ville.20090627211608.10127"><vh>imports</vh></v>
<v t="ville.20090627211608.10128"><vh>init1, init2</vh></v>
</v>
<v t="ville.20090627211608.10122"><vh>class Foo</vh>
<v t="ville.20090627211608.10123"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ville.20090627211608.10124"><vh>spam</vh></v>
<v t="ville.20090627211608.10125"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ville.20090627211608.10129"><vh>Auto nodes</vh>
<v t="ville.20090630145410.1517"><vh>@path ~</vh>
<v t="ville.20090630145410.1509"><vh>@@auto myfile_auto.py</vh>
<v t="ville.20090630145410.1510"><vh>imports &amp; setup routines</vh>
<v t="ville.20090630145410.1512"><vh>imports</vh></v>
<v t="ville.20090630145410.1511"><vh>init1, init2</vh></v>
</v>
<v t="ville.20090630145410.1513"><vh>class Foo</vh>
<v t="ville.20090630145410.1514"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ville.20090630145410.1515"><vh>spam</vh></v>
<v t="ville.20090630145410.1516"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ville.20090701175849.1532"><vh>Shadow nodes</vh>
<v t="ville.20090701175849.1542"><vh>@path ~</vh>
<v t="ville.20090701175849.1543"><vh>@@shadow myfile_shadow.py</vh>
<v t="ville.20090701175849.1544"><vh>imports &amp; setup routines</vh>
<v t="ville.20090701175849.1545"><vh>imports</vh></v>
<v t="ville.20090701175849.1546"><vh>init1, init2</vh></v>
</v>
<v t="ville.20090701175849.1547"><vh>class Foo</vh>
<v t="ville.20090701175849.1548"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ville.20090701175849.1549"><vh>spam</vh></v>
<v t="ville.20090701175849.1550"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ville.20090701184416.1554"><vh>reStructuredText (@auto-rst)</vh>
<v t="ville.20090701184416.1555"><vh>@path ~</vh>
<v t="ville.20090701184416.1556"><vh>@@auto-rst myfile_rst.txt</vh>
<v t="ville.20090701184416.1557"><vh>Main heading</vh>
<v t="ville.20090701184416.1558"><vh>subheading 1</vh></v>
<v t="ville.20090703222440.1472"><vh>subheading 2</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ville.20090630234425.12395"><vh>Configuration (enabling plugins etc.)</vh>
<v t="ville.20090630234425.14847"><vh>Find out your ~/.leo directory (script)</vh></v>
<v t="ville.20090630234425.12396"><vh>@@settings</vh>
<v t="ville.20090728003644.3957"><vh>@enabled-plugins</vh></v>
<v t="ville.20090708172716.16846"><vh>@@string initial_split_orientation = horizontal</vh></v>
<v t="ville.20090806210322.1435"><vh>suggested style sheets</vh>
<v t="ville.20090806210322.1436"><vh>default look (Linux)</vh>
<v t="ville.20090806210322.1439"><vh>@@data qt-gui-plugin-style-sheet</vh></v>
</v>
<v t="ville.20090806210322.1437"><vh>A mac look</vh>
<v t="ville.20090806210322.1440"><vh>@@data qt-gui-plugin-style-sheet</vh></v>
</v>
</v>
<v t="ville.20090806182306.6324"><vh>@int qt_max_colorized_chars = 200000</vh></v>
<v t="ville.20091008194838.3931"><vh>@data contextmenu_commands</vh></v>
<v t="ville.20120303151721.3838"><vh>@bool use_body_focus_border = False</vh></v>
<v t="ville.20121120220349.2862"><vh>@shortcut key bindings</vh></v>
</v>
<v t="ville.20121024204851.1498"><vh>Using your favorite editor to edit nodes</vh></v>
</v>
<v t="ville.20090701182804.1550"><vh>Search and replace</vh></v>
<v t="ville.20090701182804.1551"><vh>Minibuffer</vh></v>
<v t="ville.20101221125548.2199"><vh>Scripting Leo</vh>
<v t="ville.20101221131940.2204"><vh>Executing scripts with ctrl+b</vh>
<v t="ville.20101221131940.2211"><vh>Press ctrl+b here</vh></v>
</v>
<v t="ville.20101221131940.2217"><vh>Creating script buttons</vh>
<v t="ville.20101221131940.2218"><vh>@button example-btn</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20090628091852.6030">This node contains settings and other "machinery" that you
can usually ignore.</t>
<t tx="ekr.20090628091852.6031"></t>
<t tx="ekr.20090628091852.8471"></t>
<t tx="ekr.20090628092246.4267">The page width for wrapping doc parts in derived files.

Valid values: any nonzero positive integer.</t>
<t tx="ekr.20090628092604.1829">Added settings to use rest by default and use a page width
of 60 for wrapping paragraphs.

Created the startup node and its descendants.</t>
<t tx="ville.20090627211608.10116">Remove the first @ from @thin in the subtree below and save
(ctrl+s) to create an "external" file which is directly
usable outside leo - try opening the resulting myfile.py in
a normal text editor (e.g. from right-click menu on the @thin node) 
to see what it looks like.

Note the @others directive, and the the lines that look like

#@-node:ville.20090627211608.10122:class Foo

These are called "sentinels", and they are needed to
preserve the tree structure in the external files. They
allow your tree structure to survive, even when someone else
edits the source (or you edit it yourself in an external
editor).</t>
<t tx="ville.20090627211608.10117">@language python
@others
</t>
<t tx="ville.20090627211608.10118">"External file" means a file that resides on your file
system. If you are programming, these are the files you
eventually want to create to get something useful out of
Leo, for example, your C++ or Python source code files.</t>
<t tx="ville.20090627211608.10119"> </t>
<t tx="ville.20090627211608.10120"></t>
<t tx="ville.20090627211608.10122">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ville.20090627211608.10123">""" Some sort of useful class """

</t>
<t tx="ville.20090627211608.10124">def spam(self):
    pass

</t>
<t tx="ville.20090627211608.10125">def eggs(self):
    pass</t>
<t tx="ville.20090627211608.10127">import os
import sys

</t>
<t tx="ville.20090627211608.10128">def init1():
    print "init1"

def init2():
    print "init2"</t>
<t tx="ville.20090627211608.10129">If the sentinels in thin nodes are unacceptable for your workflow 
(typically the case when you are the only one using Leo in a 
particular project), you can use @auto nodes to "play well with 
others". @auto nodes understand the structure of the source code
(parsers exist for popular languages), and create the "typical"
outline for the code when the file is loaded. When you save, the outline is 
written back.

Do the same thing you did with @@thin - i.e., 

- Remove the first @, and save. 
- Check the resulting file (`/myfile_auto.py) and observe that it has 
  no sentinels.   
- There is no "magic" involved. If you execute 'File -&gt; Read auto nodes" 
  (or right click on @auto node and choose "Refresh from disk", or reopen 
  this document), you'll note that  the outline structure was lost, 
  and the "parsed" structure is created instead. This is the cost
  of using @auto nodes.</t>
<t tx="ville.20090627211608.5782">This is a brief tutorial for getting familiar with basic Leo
functionality. Click around and experiment.

Note that you probably want to save your own "working copy"
of this file before proceeding further. Do that by "File -&gt;
Save as".

This guide is intentionally quite brief and minimal -
therefore, it merely scratches the surface of what Leo can
do. You can begin leveraging Leo for mindmapping-like tasks
by just reading the node "Tree manipulation basics", and
moving on to other topics after acquiring some basic
familiarity. </t>
<t tx="ville.20090627211608.5783"></t>
<t tx="ville.20090627211608.5784">You can use Leo as fairly typical outliner. Play around with
some of the commands from the Outline menu:

- Click the expansion box of nodes_ to show and hide their
  children.

- The ``Insert Node`` command (``Ctrl+I``) inserts a new
  headline into the outline.

- The ``Cut Node`` command (``Ctrl+Shift+X``) deletes a
  headline and all its children, and copies the structure to
  clipboard - ready to paste with ``Paste Node`` command
  (``Ctrl+Shift+V``). Use ``Copy Node`` command
  (``Ctrl+Shift+C``) to copy node to clipboard without
  deleting it from outline. Copy-paste command family works
  across different Leo documents and processes.

- The ``Move Up`` (``Ctrl+U``), ``Move Down`` (``Ctrl+D``),
  ``Move Left`` (``Ctrl+L``) and ``Move Right`` (``Ctrl+R``)
  commands move the currently selected node, along with all
  its descendants.

- The ``Promote`` (``Ctrl+{``) command makes all the
  children of a headline siblings of the headline. The
  ``Demote`` (``Ctrl+}``) command makes all following
  siblings_ of a headline children of the headline.

- Move around the tree and expand/collapse nodes by pressing
  Alt + arrow keys. This also moves the focus to tree, so,
  after pressing Alt + arrow, you can move around by using
  arrow keys alone. Return the focus to the body control by
  pressing ``Enter``.

- To edit the headline, use press ``Ctrl+H``. This works
  regardless of whether body or headline has focus.

You enter `body text` for any node by selecting the node's
headline in the outline pane and then typing in the body
pane. Leo has a full range of `editing commands` that apply
to the body pane.

See Leo's documentation for more detailed discussion.</t>
<t tx="ville.20090630145410.1509">@language python
@others
</t>
<t tx="ville.20090630145410.1510"></t>
<t tx="ville.20090630145410.1511">def init1():
    print "init1"

def init2():
    print "init2"</t>
<t tx="ville.20090630145410.1512">import os
import sys

</t>
<t tx="ville.20090630145410.1513">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ville.20090630145410.1514">""" Some sort of useful class """

</t>
<t tx="ville.20090630145410.1515">def spam(self):
    pass

</t>
<t tx="ville.20090630145410.1516">def eggs(self):
    pass</t>
<t tx="ville.20090630145410.1517"></t>
<t tx="ville.20090630234425.12394"></t>
<t tx="ville.20090630234425.12395">If you are just starting, you should create your own myLeoSettings.leo in ~/.leo. We'll do that next.

Create the file first: 
  - File -&gt; New (or ctrl+N)
  - File -&gt; Save as
  - Navigate to ~/.leo
  - save as myLeoSettings.leo

In the current tree, there is @@settings subtree. We are
copying this to the new file. Go to node @@settings, and
copy the whole tree to clipboard (ctrl+shift+c).
  
Select the document that has myLeoSettings.leo (the one you
just created). Drop the settings tree there (ctrl+shift+v),
Remove extra @ from @@settings, and save again.

Now, you should be all set. Verify that it worked by Help-&gt;open myLeoSettings.leo
</t>
<t tx="ville.20090630234425.12396"></t>
<t tx="ville.20090630234425.14847"># execute this script by ctrl+b to find out where your ~/.leo is

g.es('Homedir is at ',g.app.homeLeoDir)

</t>
<t tx="ville.20090701175849.1532">In this tree, you can experiment with @shadow. It combines the benefits
of @thin and @auto - namely, it publishes a file without sentinels, but
still allows the tree structure to survive, even if the external file
is edited outside Leo.

The cost is complexity - @shadow relies on a "shadow file" that remembers
the structure, and a sophisticated diff/patch algorithm that merges
the changes from the external file to the tree structure.

Experiment by editing the external file outside Leo and doing Right click
-&gt; refresh from disk on the @shadow node. </t>
<t tx="ville.20090701175849.1542"></t>
<t tx="ville.20090701175849.1543">@language python
@others
</t>
<t tx="ville.20090701175849.1544"></t>
<t tx="ville.20090701175849.1545">import os
import sys

</t>
<t tx="ville.20090701175849.1546">def init1():
    print "init1"

def init2():
    print "init2"</t>
<t tx="ville.20090701175849.1547">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ville.20090701175849.1548">""" Some sort of useful class """

</t>
<t tx="ville.20090701175849.1549">def spam(self):
    pass

</t>
<t tx="ville.20090701175849.1550">def eggs(self):
    pass</t>
<t tx="ville.20090701182804.1550">Press ctrl + F to enter "minibuffer find" mode. Press F3 to
"find again".

For large scale searches (classic "find in files"
functionality for the whole tree), look for the "Nav" tab in
the log pane (in upper right of the screen). Enter your
search string and press enter, then click on the matches.

You can also activate the "Nav" functionality with ctrl+shift+f.

To perform find-and replace, press ctrl-f, enter the text
to search, then press ctrl+shift+r, and enter the text to replace
the matches with, and press Enter.

To limit the replace operations to particular external file,
you can use your external editor. That is, right click on
the @thin node (say, @thin myfile.py), choose "Edit
myfile.py in MYEDITOR", and perform the necessary operations.
After that, right click on the node and choose "Refresh from 
disk".
</t>
<t tx="ville.20090701182804.1551">The minibuffer is the text input area at the bottom of the
screen, familiar to users of emacs and vi.

Press alt-x to enter a minibuffer command (e.g. alt-x
fill-paragraph). Press ctrl+p (repeat-complex-command)
folowed by Enter to re-run a previous minibuffer command.</t>
<t tx="ville.20090701184416.1554">reStructuredText (http://docutils.sourceforge.net/rst.html)
is an efficient way of authoring documentation as plain text.
Leo provides first-class support for RST authoring, including 
the unique feature of representing RST outline structure
as Leo tree. You can find an example in the tree below - again,
just remove the first @ character from @@auto-rst and save,
opening the external file afterwards.
</t>
<t tx="ville.20090701184416.1555"></t>
<t tx="ville.20090701184416.1556" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e65733171036802752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.

</t>
<t tx="ville.20090701184416.1557">Observe the underlining style of the headings.
</t>
<t tx="ville.20090701184416.1558">Some text in first other chapter.
</t>
<t tx="ville.20090703222440.1472">More text in other chapter.</t>
<t tx="ville.20090708172716.16846">horizontal: body pane to the left
vertical: body pane on the botton

vertical is the default; you may prefer horizontal for small but wide screens (e.g. on laptops)</t>
<t tx="ville.20090728003644.3957"># Leo loads plugins in the order they appear here.
# File names may be indented as desired.

# Standard plugins enabled in official distributions....

plugins_menu.py
leo_to_html.py
mod_scripting.py
quicksearch.py
contextmenu.py
nav_qt.py

# The plugins manager plugin does not
# understand @enabled-plugins nodes.
# plugin_manager.py

# The rst3 plugin is no longer needed.
# It's code has been moved to Leo's core
# rst3.py

# These plugins used to be enabled when using the tk plugin.
# cleo.py
# hoist.py
# image.py
# nav_buttons.py
# threading_colorizer.py

# All other plugins.
# Order is important for enabled plugins that
# add items to the icon area.

# ConceptualSort.py
# EditAttributes.py
# FileActions.py
# Library.py
# nodeActions.py
# UASearch.py
# URLloader.py
# UniversalScrolling.py

# add_directives.py
# arrows.py
# at_folder.py
# at_view.py
# autotrees.py
# base64Packager.py
# bibtex.py
# chapter_hoist.py
# cleo.py
# color_markup.py
# datenodes.py
# detect_urls.py
# dyna_menu.py
# fastGotoNode.py
# footprints.py
# groupOperations.py
# hoist.py
# image.py
# import_cisco_config.py
# ipython.py
# keybindings.py
# leoOPML.py
# leo_to_html.py
# leo_to_rtf.py
# leoupdate.py
# macros.py
# mod_autosave.py
# mod_http.py
# mod_labels.py
# mod_read_dir_outline.py
# mod_shadow.py
# multifile.py
# nav_buttons.py
# newButtons.py
# niceNosent.py
# nodebar.py
# nodenavigator.py
# open_shell.py
# open_with.py
# paste_as_headlines.py
# pie_menus.py
# pretty_print.py
# print_cp.py
# quickMove.py
# rClick.py
# read_only_nodes.py
# rowcol.py
# run_nodes.py
# s_menu.py
# scheduler.py
# searchbox.py
# shortcut_button.py
# slideshow.py
# table.py
# templates.py
# trace_tags.py
# vim.py
# word_count.py
# word_export.py
# xcc_nodes.py
# xemacs.py
# xsltWithNodes.py
# zodb.py
# quicksearch.py
# tomboy_import.py
# ctagscompleter.py
# colorize_headlines.py</t>
<t tx="ville.20090806182306.6324">If zero, all nodes are colorized, regardless of length of body text.
If &gt; 0, only nodes whose body text are smaller than this limit are colorized.</t>
<t tx="ville.20090806210322.1435">This tree containt some suggested "looks" for Leo.

To experiment, you may want to use a @button that applies
the stylesheet in current node; look for "@button set-style-sheet" 
in scripts.leo.

For information on stylesheets, see

http://doc.trolltech.com/stylesheet.html

Style contributions are welcome.</t>
<t tx="ville.20090806210322.1436">Classic Leo colors. This should look good on Linux.</t>
<t tx="ville.20090806210322.1437">This is the classic Leo look, but with fonts that
allegedly look better on Mac.</t>
<t tx="ville.20090806210322.1439">/* Documentation of Qt stylesheets at http://doc.trolltech.com/stylesheet.html 

To experiment, you may want to use a @button that applies
the current stylesheet; look for "@button set-style-sheet" in
scripts.leo.

*/

/* Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords */

/* A QWidget: supports only background attributes.*/

QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: white;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: DejaVu Sans Mono;
    /* font-family: Courier New; */
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}

/* The mini-buffer */
QLineEdit#lineEdit {
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#status1 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

QLineEdit#status2 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

XXQPushButton {
    background-color: #fdf5f5; /* A kind of pink. */
    margin: 2px;
    padding; 4px;
    border-width: 2px;
    border-style: solid;
    border-color: darkgrey;
}

/* QMenuBar works, but not QMenu... */
XXQMenuBar {
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}
</t>
<t tx="ville.20090806210322.1440">/* Documentation of Qt stylesheets at http://doc.trolltech.com/4.2/stylesheet.html */

/* Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords */

/* A QWidget: supports only background attributes.*/

QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: white;
    selection-background-color: blue;
    font-family: Monaco;
    font-size: 10px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: Monaco;
    /* font-family: Courier New; */
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}

/* The mini-buffer */
QLineEdit#lineEdit {
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: Monaco;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#status1 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

QLineEdit#status2 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

XXQPushButton {
    background-color: #fdf5f5; /* A kind of pink. */
    margin: 2px;
    padding; 4px;
    border-width: 2px;
    border-style: solid;
    border-color: darkgrey;
}

/* QMenuBar works, but not QMenu... */
XXQMenuBar {
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}</t>
<t tx="ville.20091008194838.3931"># Add commands to contextmenu
# The format is &lt;command&gt; SPACE &lt;description&gt;

# stickynote Create a sticky note
# read-at-file-nodes Read file node</t>
<t tx="ville.20101221125548.2199">Eventually, you will want to add extra functionality to your
Leo documents. There are a few simple ways, and unlimited 
power for advanced users

</t>
<t tx="ville.20101221131940.2204">You can write scripts in your document trees, and execute
them with ctrl+b. Try it on the child of this node - it
should display the list of nodes that have a headline
starting with @ in the log pane.

It will also append the summary as a new node under itself.

</t>
<t tx="ville.20101221131940.2211">@language python
# c is "commander", central api object specific to current document 

# get a list of "position" objects
nodes = c.find_h('^@')

res = []
for n in nodes:
    # .b gets the body text, .h is headline
    body = n.b
    res.append("- " + n.h)
    
    res.append("   " + str(body.count('\n')) + " lines")
    
# 'p' is the 'current position'    
child = p.insertAsLastChild()    
child.b = "\n".join(res)
child.h = "Report"

c.redraw()    </t>
<t tx="ville.20101221131940.2217">You can create buttons in the button bar by adding @button
nodes to your outline.

A button does not appear automatically when you add it - you
need to reopen the document to make it appear.

</t>
<t tx="ville.20101221131940.2218"># p is current position

g.es("p.h is " + p.h)</t>
<t tx="ville.20120303151721.3838">Avoid red focus borders in body pane (if it's not in your aesthetic taste)</t>
<t tx="ville.20121024204851.1498">If you occasionally want to use an alternative editor to
edit body text (e.g. when Leo is still missing a feature
your regular editor has), you can right click on a node and
select "edit in FOO" (where FOO is your alternative editor).
You can change the suggested editor by setting environment
variable LEO_EDITOR - as an example, add this to your
~/.bashrc:

export LEO_EDITOR=gedit

(you obviously need to parse ~/.bashrc before it takes
effect).

If LEO_EDITOR is not defined, EDITOR is used instead.

You can also change the external editor directly from Leo by
executing this as a Leo script:

g.app.db['LEO_EDITOR'] = "gvim"
</t>
<t tx="ville.20121120220349.2862">go-anywhere = ctrl+g</t>
</tnodes>
</leo_file>
