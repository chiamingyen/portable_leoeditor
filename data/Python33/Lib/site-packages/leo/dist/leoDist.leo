<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20050315084904"><vh>Startup</vh>
<v t="ekr.20070325123540"><vh>@chapters</vh></v>
</v>
<v t="EKR.20040519091259"><vh>Annoucements</vh>
<v t="EKR.20040519091259.1"><vh>Download statistics</vh></v>
<v t="ekr.20101115090518.1494"><vh>Leo 4.8 final</vh></v>
<v t="ekr.20110603112852.1505"><vh>Leo 4.9 final</vh></v>
<v t="ekr.20120328150744.1791"><vh>Leo 4.10 final</vh></v>
<v t="EKR.20040519091259.2"><vh>Quotes of the month</vh>
<v t="ekr.20080901114425.2"><vh>Sept 2008</vh></v>
<v t="ekr.20070425092712"><vh>April 2007</vh></v>
<v t="ekr.20070101093904"><vh>January 2007</vh></v>
<v t="ekr.20060823090437"><vh>August 2006</vh></v>
<v t="ekr.20060213160806"><vh>February 2005</vh></v>
<v t="ekr.20040828084148"><vh>August 2004</vh></v>
<v t="ekr.20040630210818"><vh>July 2004</vh></v>
<v t="EKR.20040519091259.3"><vh>November 2003</vh></v>
<v t="EKR.20040519091259.4"><vh>October 2003</vh></v>
</v>
</v>
<v t="ekr.20100202061222.1494"><vh>Distribution checklist</vh></v>
<v t="EKR.20040519090846"><vh>Distribution files</vh>
<v t="EKR.20040519090846.2"><vh>@asis ../../INSTALL.TXT</vh>
<v t="EKR.20040519090846.3"><vh>System requirements</vh></v>
<v t="ekr.20080825083632.262"><vh>Leo's HOME directory</vh></v>
<v t="EKR.20040519090846.4"><vh>Linux installation</vh></v>
<v t="EKR.20040519090846.5"><vh>Windows installation</vh></v>
<v t="ekr.20080825083632.263"><vh>Running Leo</vh></v>
</v>
<v t="EKR.20040519090846.1"><vh>@asis ../../LICENSE.TXT</vh></v>
<v t="EKR.20040519090846.8"><vh>@asis ../../PKG-INFO.TXT</vh></v>
<v t="EKR.20040519090846.9"><vh>@asis ../../README.TXT</vh></v>
</v>
<v t="ekr.20101025095431.1517"><vh>Installer/Distribution to do</vh>
<v t="ekr.20101025095431.1518"><vh>Bug 514656 Uninstall operation does not work as expected</vh>
<v t="ekr.20090901092556.1576"><vh>genUninstallData &amp; helpers</vh>
<v t="ekr.20090901121423.1568"><vh>getDeleteDirectories</vh></v>
<v t="ekr.20090901121423.1569"><vh>getDeleteFiles</vh></v>
<v t="ekr.20090901121423.1567"><vh>getUninstallVariableData</vh></v>
</v>
</v>
<v t="ekr.20101026142031.1516"><vh>Registry Keys</vh></v>
</v>
<v t="ekr.20101027070126.1639"><vh>@button make leo</vh>
<v t="ekr.20090905082405.1487"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="ekr.20110614062644.1379"><vh>&lt;&lt; define global paths and file names &gt;&gt;</vh></v>
<v t="ekr.20101027070126.1643"><vh>class LeoMaker</vh>
<v t="ekr.20101027070126.1662"><vh>run &amp; helpers</vh>
<v t="ekr.20101105103524.1494"><vh>clean_manifest</vh></v>
<v t="ekr.20110603171959.1506"><vh>clean_spellpyx</vh></v>
<v t="ekr.20110614062644.1378"><vh>copy_ref_files</vh></v>
<v t="ekr.20101027070126.1675"><vh>create_install_files</vh></v>
<v t="ekr.20101027070126.1676"><vh>create_uninstall_files</vh></v>
<v t="ekr.20101027070126.1663"><vh>directoryList</vh></v>
<v t="ekr.20101027070126.1664"><vh>filterLines &amp; helpers</vh>
<v t="ekr.20101027070126.1665"><vh>delete...</vh></v>
</v>
<v t="ekr.20101105103524.1491"><vh>make_manifest</vh></v>
<v t="ekr.20101105103524.1493"><vh>make_zip</vh></v>
<v t="ekr.20101027070126.1666"><vh>makeDicts</vh></v>
<v t="ekr.20101027070126.1667"><vh>printMissing</vh></v>
</v>
<v t="ekr.20101027070126.1680"><vh>utils...</vh>
<v t="ekr.20101027070126.1679"><vh>openFile</vh></v>
<v t="ekr.20101027070126.1678"><vh>put</vh></v>
<v t="ekr.20090905082405.1490"><vh>unlink</vh></v>
</v>
</v>
</v>
<v t="ekr.20101027131034.1490"><vh>NSIS source files</vh>
<v t="ekr.20101027160251.1500"><vh>Notes</vh>
<v t="ekr.20101027135430.1492"><vh>@url nsi new ui readme</vh></v>
<v t="ekr.20101027135430.1493"><vh>@url about pages</vh></v>
<v t="ekr.20101027160251.1497"><vh>@url nsDialogs</vh></v>
</v>
<v t="ekr.20101027054254.1590"><vh>@edit ../../leo.nsi</vh></v>
<v t="ekr.20101027115225.1494"><vh>@thin nsi-boilerplate.txt</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040519090846">@language rest

1. Search for ##version

2. Search for this suffix: -final.

3. Search for copyright

    Latest copyright date: 2012.

    Note: install.txt file embeds a copyright message in the nsi installer.</t>
<t tx="EKR.20040519090846.1">Leo is Open Software and is distributed under the terms of the MIT
License. The gist of the license is that Leo is absolutely free, even
for commercial use (including resale). There is no GNU-like "copyleft"
restriction. The Open Source Initiative board has voted to certify the
MIT license as Open Source. This license is compatible with the GPL.

Copyright (c) 1997-2012 by Edward K. Ream. All Rights Reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Leo or Edward K. Ream
not be used in advertising or publicity pertaining to distribution of
the software without specific, written prior permission.

DISCLAIMER OF WARRANTIES

EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED
OR IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT
LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE. IN NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF
PROFIT OR ANY COMMERCIAL DAMAGE, INCLUDING BUT NOT LIMITED TO SPECIAL,
INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES.
</t>
<t tx="EKR.20040519090846.2"></t>
<t tx="EKR.20040519090846.3">System requirements
-------------------

Leo requires Python 2.6 or above (including Python 3.x) and PyQt.

- Download Python from http://python.org/
    
- Download PyQt from http://www.riverbankcomputing.co.uk/news
</t>
<t tx="EKR.20040519090846.4">
Installing Leo on Linux
-----------------------

Download the latest version of Leo (a .zip file) from `Leo's download page`_.

Unzip the downloaded .zip file into the **unpacked folder** in your home directory.
The unpacked folder will be called something like leo-4-5.

You can run Leo from your home directory.
You can add  ~/leo-4.10 to your path, or you can create an alias that executes::

    python ~/leo-4-10/launchLeo.py
</t>
<t tx="EKR.20040519090846.5">
Installing Leo on Windows
--------------------------

There are now two ways to install Leo on Windows:
    
1. Use the single-click executable installer, named something like
   LeoSetup-4.10-final.exe

2. Leo is distributed as a .zip file.
   To install Leo from the .zip file:

    1. Download the latest version of Leo (a .zip file) from:    
       http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

    2. Unzip the .zip file and place the unpacked leo folder in 
       the 'Program Files' folder or any convenient location.

    After you have installed Leo, you should add the location of your leo/core folder to your python path.
    One way to do this is adding something like the following to python/Lib/sitecustomize.py:

        import sys
        sys.path.append(r'&lt;path-to-leo&gt;leo\core')

    Another way is to append &lt;path-to-leo&gt; to the Windows PYTHONPATH environment variable.
</t>
<t tx="EKR.20040519090846.8">Metadata-Version: 1.0
Name: leo
Version: 4.10-final
Summary: Leo: Literate Editor with Outlines
Home-page: http://webpages.charter.net/edreamleo/front.html
Author: Edward K. Ream
Author-email: edreamleo@charter.net
License: Python
Description:
    Leo is an outline-oriented IDE written in 100% pure Python.
    Leo features a multi-window outlining editor, Python colorizing,
    powerful outline commands and many other things, including 
    unlimited Undo/Redo and an integrated Python shell(IDLE) window.
    Leo requires Python 2.6 or above.  Leo works with Python 3.x.
Platform: Windows, Linux
</t>
<t tx="EKR.20040519090846.9">Leo 4.10 final                                         March 29, 2012

Leo 4.10 final is now available at: http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
http://webpages.charter.net/edreamleo/intro.html

Leo 4.10 contains 9 months of intense work on Leo. Several very important
features are subtle; you could almost call them Easter Eggs, so please read
the following notes carefully.

The highlights of Leo 4.10:
--------------------------

* Dozens of new and improved features and commands, including...
  - Tab completion now shows all @command &amp; @button nodes.
  - Leo tabs may be detached from the main window.
  - The Open With menu now works.
  - The leoInspect module answers questions about Python code.
  - Leo can highlight the pane containing the focus.
  - The bigdash plugin searches across multiple files.
  - Improved abbreviation capabilities.
  - Improved handling of URL's.
  - Improved editing of non-Leo files.
  - Improvements create "weightless" unit testing.
  - Improved Leo's home page.
* Easier installation on MacOS.
* Fixed almost 70 bugs.

The Easter Eggs
---------------

1. Tab completion now shows all @command &amp; @button nodes.

Put all your common scripts in @command nodes in myLeoSettings.leo.
Typing &lt;Alt-X&gt;@c&lt;Tab&gt; will remind you of the names of these scripts.
You can execute the scripts by name without the "@command-" prefix.

2. Improved abbreviation capabilities.

Virtually any kind of abbreviation is possible. For example, ~a to Ã£.

3. Improved handling of URL's.

URL's can be used as links to other Leo outlines.

4 Weightless unit testing.

The mantra is edit, alt-4 (run-marked-unit-tests-externally), edit,
alt-4,... Several seemingly innocuous changes made this work without
"friction". The result is a remarkable increase in productivity.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="EKR.20040519091259">@pagewidth 70

@language rest
</t>
<t tx="EKR.20040519091259.1">4.4.5       setup: 547  zip: 379  2007-12-11
4.4.4       setup: 856  zip: 539  2007-11-02
4.4.3.1     setup: 1092 zip: 743  2007-7-03
4.4.3       setup: 363  zip: 282  2007-6-26
4.4.2.1     setup: 2847 zip: 2044 2006-10-19
4.4.1.1     setup: 1041 zip: 813  2006-9-3
4.4         setup: 1318 zip: 1075 2006-5-11
3.3.3       setup: 1503 zip: 1145 2005-9-19
4.3.2 final setup: 409  zip: 222
4.3.1 final setup: 2168 zip: 1781
4.3 final   setup: 942  zip: 686
4.2.1 final setup: 413  zip: 490
4.2-final   setup: 1828 zip: 1508
4.2b3       setup: 563, zip: 338
4.1rc3      setup: 870  zip: 630
4.1 b5      setup: 195, zip: 128
4.0.4       setup: 340, zip: 385
4.0                     zip: 382
3.12        setup: 953  zip: 592
3.11                    zip: 102
3.10                    zip: 1193</t>
<t tx="EKR.20040519091259.2"></t>
<t tx="EKR.20040519091259.3">I like Leo more the more I use it...It's an unexpected pleasure to
see my (linearly written) code outlined in Leo. I can't wait to use
Leo to start a new project, going from outline to code...Thanks again
for providing the computing community with such a fine piece of
software. -- Jim Shapiro, Ph.D.

If you think you have used all possible programmer's editors, but
have not yet tried Leo, you are wrong...I rate Leo as a "must have"
for Python programmers. The code makes for a good read.
-- John Tobler  http://weblogs.asp.net/Jtobler/
</t>
<t tx="EKR.20040519091259.4">I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in LEO, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols dnichols@amci.com</t>
<t tx="ekr.20040630210818">HTML Editing in Leo is soooo much easier then with NoNodeEditors. Ive
had a blast working on a web page. Usually I had to look at a bunch of
gunk all at once. Now I can look at little pieces of gunk! :) 

-Anon (for now)

Before leo, I try to avoid or refactor long functions. With leo, I am
very tempted not to. Being able to view and slice my code at a higher
level in pretty much anyway I want, I feel like a commanding master in
my own mess...Leo lets me be lazy and get away with it. ;)

Mark Ng

[Quote] I have just finished a little embedded system for someone, written in
C using leo as the editor. I told the customer he _had_ to use leo for
ongoing maintenance, after I looked at one of the main state machines:
600 lines in the derived file, but trivialy easy to get your head
around in Leo...

The good news is that having been forced to meet leo he thinks it'll
solve many other problems that his company has with code maintenance.
Another step to world domination!

Leo allows you to do things that you'd never consider with another editor. 

BTW: in a real-time embedded system like I was working on, not having
the overhead of a function call (which you'd have had if you'd split
the case statement as you would with a normal editor) saves time, and
makes the system more flexible...
[End Quote]</t>
<t tx="ekr.20040828084148">Leo is the best IDE that I have had the pleasure to use. I have been using it
now for about 2 -- 3 months. It has totally changed not only the way that I
program, but also the way that I store and organise all of the information that
I need for the job that I do. -- Ian Mulvany</t>
<t tx="ekr.20050315084904"></t>
<t tx="ekr.20060213160806">"Thanks for a wonderful program â everybody should be using it! It blows the
socks off that Java Mind mapping software that won project of the month a while
back on sourceforge!" -- Derick van Niekerk.
</t>
<t tx="ekr.20060823090437">Thanks for creating the most useful and amazing application that
I've come across in years. I use Leo every day.</t>
<t tx="ekr.20070101093904">Leo is THE BEST THING to ever had happened to me. I've done in two
weeks what would have taken me years (not exaggerating!). Thanks Ed
for a terrific tool!!!!
 
Julian S. Fecteau 
</t>
<t tx="ekr.20070325123540"></t>
<t tx="ekr.20070425092712">Leo--especially with its feature of user-controllable outlining and
overview __has for the last 4-5 years had the greatest positive effect
on my overall programming quality of life than anything else out there
in the software world (apart maybe from the Python language itself,
and those who contribute Python modules to the world). -- David McNab
</t>
<t tx="ekr.20080825083632.262">
Leo's HOME directory
--------------------

Python's HOME environment variable specifies Leo's HOME directory.
See http://docs.python.org/lib/os-procinfo.html for details.

Leo puts several files in your HOME/.leo directory:
.leoID.txt, .leoRecentFiles.txt, and myLeoSettings.leo.
There are various fallback directories if there is no home directory.
</t>
<t tx="ekr.20080825083632.263">
Running Leo
-----------

You can run Leo from a Python interpreter as follows::

    import leo
    leo.run() # runs Leo, opening a new outline or,
    leo.run(fileName=aFileName) # runs Leo, opening the given file name.

Another way to run Leo is as follows::

    cd &lt;path-to-launchLeo.py&gt;
    python launchLeo.py

Here are some tips that may make running Leo easier:

**Linux**
    The following shell script will allow you to open foo.leo files by typing leo foo::

        #!/bin/sh 
        python &lt;leopath&gt;launchLeo.py $1

    where &lt;leopath&gt; is the path to the directory *containing* the leo directory. 

**Windows**
    You can associate Leo with .leo files using a batch file. Put the
    following .bat file in c:\\Windows::

        &lt;path-to-python&gt;/python &lt;path-to-leo&gt;/launchLeo.py %*

    Here &lt;path-to-leo&gt; is the path to the directory *containing* the leo directory,
    that is, the directory containing launchLeo.py.

The first time you start Leo, a dialog will ask you for a unique identifier. If
you are using cvs, use your cvs login name. Otherwise your initials will do. Leo
stores this identifier in the file ``.leoID.txt``. Leo attempts to create
``leoID.txt`` in the .leo sub-directory of your home directory, then in Leo's config directory, and
finally in Leo's core directory. You can change this identifier at any time by
editing ``.leoID.txt``.</t>
<t tx="ekr.20080901114425.2">For me Squeak and Leo have been two of the most significant technologies to
redefine my personal computer experience and the ideas behind computing.</t>
<t tx="ekr.20090901092556.1576">def genUninstallData(self,dirs,dirDict,filesDict):

    '''Generate the manifest-specific uninstall data.'''

    trace = True

    s = r'''
Section Uninstall

    DeleteRegKey HKEY_LOCAL_MACHINE "${hkey_local_machine}"

    ; Delete files &amp; directories only if we own them!
    ReadRegStr $$1 HKCR "${ext}" ""
    StrCmp $$1 "${name}File" 0 FinishUninstall

    ; Delete files &amp; directories only if there is no backup_val key.
    ReadRegStr $$1 HKCR "${ext}" "backup_val"
    StrCmp $$1 "" 0 DeleteLeoKeysAndFiles
      DeleteRegKey HKCR "${ext}"
    Goto FinishUninstall

DeleteLeoKeysAndFiles:
    WriteRegStr HKCR "${ext}" "" $$1
    DeleteRegValue HKCR "${ext}" "backup_val"

    ; ---- Start of manifest-related data...
'''

    self.put(s,substitute=True)

    # Does all the hard work.
    s = self.getUninstallVariableData(dirs,dirDict,filesDict)
    if trace: g.trace('\n',s)
    self.put(s,adjust = False)

    s = r'''
    ; ---- End of manifest related data.

FinishUninstall:
    ; MessageBox MB_YESNO|MB_ICONQUESTION \
    ;    "Delete all files in ${INSTDIR}?" IDNO NoDelete
; NoDelete:

  Delete "${SMPROGRAMS}\${name}\Uninstall.lnk"
  RMDir "${SMPROGRAMS}\${name}-${version}"
  Delete "${DESKTOP}\${name}.lnk"

  DeleteRegKey ${uninst_root_key} "${uninst_key}"
  SetAutoClose false

; end Uninstall section
SectionEnd
'''

    self.put(s,substitute=True)
</t>
<t tx="ekr.20090901121423.1567">def getUninstallVariableData(self,dirs,dirDict,filesDict):

    s1 = self.getDeleteFiles(dirs,dirDict,filesDict)
    s2 = self.getDeleteDirectories(dirs,dirDict)
    return '%s\n%s' % (s1,s2)
</t>
<t tx="ekr.20090901121423.1568">def getDeleteDirectories (self,dirs,dirDict):

    reverseDirs = dirs[:]
    reverseDirs.reverse()

    result = []

    if 1:
        result.append('; Recursively delete the leo directory and everything in it.\n')
        result.append('RMDir /r "$INSTDIR\\leo"\n\n')
    else:
        result.append('; Uninstall directories in reverse order\n')
        for theDir in reverseDirs:
            # Delete the directory even if it has files.
            if theDir and theDir != '**top':
                if not theDir.startswith('.bzr'):
                    result.append('RMDir "$INSTDIR\\%s"\n' % (
                        theDir.replace('/','\\')))

    # top-level folder.
    result.append('; Delete the top-level directory.\n')
    result.append('RMDir "$INSTDIR"\n')

    result = [self.indent(z) for z in result]
    return ''.join(result)
</t>
<t tx="ekr.20090901121423.1569">def getDeleteFiles (self,dirs,dirDict,filesDict):

    result = []
    result.append('\n')
    result.append('; Uninstall files...\n\n')

    # top-level files.
    result.append('; Delete top-level files...\n')
    aList = dirDict.get('**top',[])
    # Add *.py, *.pyo, *.pyc and *.leo, the most common added files.
    if 0: # This seems way too drastic, and not needed.
        for fn in ('*.py','*.pyo','*.pyc','*.leo',):
            aList.append(fn)
    # special case.
    aList.append('uninst.exe')
    # Warning: **never** delete all files in the top-level directory.
    for fn in aList:
        result.append('Delete "$INSTDIR\\%s"\n' % fn)

    if 0:
        wildcard_delete = True
        if wildcard_delete:
            result.append('\n')
        # Use the \r option to recursively delete everything in the leo directory.

        for theDir in dirs:
            if theDir:
                dir2 = theDir.replace('/','\\')
                if wildcard_delete:
                    result.append('Delete "$INSTDIR\\%s\\*.*"\n' % (dir2))
                else:
                    aList = dirDict.get(theDir,[])
                    if aList:
                        result.append('\n')
                        result.append('Delete "$INSTDIR\\%s\\*.pyc"\n' % (dir2))
                        result.append('Delete "$INSTDIR\\%s\\*.pyo"\n' % (dir2))
                    for fn in aList:
                        result.append('Delete "$INSTDIR\\%s\\%s"\n' % (
                            dir2,fn))

    result = [self.indent(z) for z in result]
    return ''.join(result)
</t>
<t tx="ekr.20090905082405.1487">import os
import shutil
import string
import struct
import subprocess
import sys
import time</t>
<t tx="ekr.20090905082405.1490">def unlink (self,fn):

    print('command: unlink: %s' % fn)
    os.remove(fn)
</t>
<t tx="ekr.20100202061222.1494">@nocolor-node

Clean files and create a *trial* manifest.
    (The make-leo button runs make-leo-manifest automatically.)
    - Delete any unknow files reported by bzr status.
    - Run make-leo-manifest (a .bat file).
Pre-testing:
    - Run all unit tests.
    - Run pylint -a.
Release notes and web documentation:
    - Update the release notes.
    - Copy release notes to leoDist.leo.
    - Update version number and modification date on Leo's home page.
    - (The sphinx date is updated automatically.)
    - Regenerate all .html files.
    - Copy files to web.  Include the home page, but *not* the toc.
LeoPy.leo:
    - Update version numbers.
    - Update the build number.
LeoDocs.leo:
    - ** Update version numbers in html/conf.py
    - Remove top-level clones.
    - Select the readme node.
LeoPlugins.leo:
    - Remove top-level clones.
Post-testing:
    - Run all unit tests.
LeoDist.leo:
    - Make sure copyright dates are correct.
        (trunk/license.txt **and** leo/doc/license.txt.)
    - Update version numbers: search leoDist.leo for ##version.
    - Update readme.txt
    - Check 'PKG-INFO.TXT'
Run make-leo, making sure that the final revno matches the build number in version.py:
    - Commit all files before running make-leo.  This provides a baseline.
    - Run make-leo button in leoDist.leo.
        - This creates bzr-manifest.txt and all other variable distribution files.
        - This will change bzr-manifest by a little bit from the previously-computed manifest.
    - Commit the slightly-changed bzr-manifest.txt.
    - Change the build number in version.py to one more than the present revno.
    - Commit the change to version.py, thereby making the build number match the final revno.
Create the executable installer:
    - Choose leo.nsi in Windows Explorer and select "Compile NSI Script"
    - or just double-click leo.nsi.
Test files in installed folder.
    - Run all unit tests in the installed folder, with the installed Leo.
    - Make sure the following open without errors:
        - leoPlugins.leo
        - leoPy.leo
        - LeoDocs.leo
Create a bzr tag **last**.
    - Update the build number.  Open any Leo file to test.
    - bzr tag leo-x-y
    - bzr commit --unchanged -m "added tag"
    - bzr push
Optional: update leoDist.leo *after* doing the commit that adds the tag.
    - This ensures that leoDist.leo in the distro matches the leoDist.leo in the tagged revno.
@color
# **** Scan all folders &amp; files before uploading.
@nocolor

Create Release on SourceForge:
    http://sourceforge.net/projects/leo/

Announcements
- Update version number on Leo's wikipedia site:
    http://en.wikipedia.org/wiki/Leo_(editor)
    - Edit with the 'Edit this page' *tab* (not a link)
- Update version number on web site.
- Announce to SourceForge itself.
- Announce to leo-editor.
- Announce to comp.lang.python: google comp.lang.python
- Register Leo at http://www.python.org/pypi?:action=submit_form
- Twitter
- My blog</t>
<t tx="ekr.20101025095431.1517"></t>
<t tx="ekr.20101025095431.1518">@nocolor-node

On Sun, Oct 17, 2010 at 12:04 PM, David Szent-GyÃ¶rgyi
&lt;514656@bugs.launchpad.net&gt; wrote:

Perhaps changing the current working directory away from the installation
directory before applying the NSIS RMDir command to the installation directory
would work.

If not, use the /REBOOTOK option of the RmDir command to force
deletion of the installation folder on the next reboot.

Both these techniques are described at
http://nsis.sourceforge.net/Docs/Chapter4.html#4.9.1.8
</t>
<t tx="ekr.20101026142031.1516">@nocolor-node

HKEY_CURRENT_USER\Software\Classes\Applications\python.exe
HKEY_CURRENT_USER\Software\Classes\Applications\python.exe\shell\open\command
    val = c:\Python26\python.exe %1
HKCU
HKEY_CURRENT_USER\Software\Classes\Applications\pythonw.exe
HKEY_CURRENT_USER\Software\Classes\Applications\pythonw.exe\shell\open\command
    val = c:\Python26\pythonw.exe %1

HKEY_CURRENT_USER\Software\Classes\Applications\py_auto_file\shell\open\command
    val = c:\Python26\python.exe %1
    
HKEY_CURRENT_USER\Software\Classes\Installer\Products\nnnnnn

HKLM
HKEY_LOCAL_MACHINE\SOFTWARE\Python
HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore
HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\2.7\InstallPath
    val = c:\python27\
HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonPath
    val = c:\Python27\Lib;\Python27\DLLs;C:\Python27\Lib\lib-tk
</t>
<t tx="ekr.20101027070126.1639">'''Make all variable Leo distribution files::

        bzr-manifest.txt
        leo\dist\nsi-install-files.txt
        leo\dist\nsi-uninstall-files.txt
        leo.zip.
'''

version = '4.10-final' ##version

&lt;&lt; includes &gt;&gt;
&lt;&lt; define global paths and file names &gt;&gt;

@others

LeoMaker().run()
# LeoMaker().copy_ref_files()

g.es_print('@button make-leo done')
</t>
<t tx="ekr.20101027070126.1643">class LeoMaker:

    '''A class to make Leo distribution files:

    bzr-manifest.txt.
    leo\dist\nsi-install-files.txt
    leo\dist\nsi-uninstall-files.txt
    leo.zip
    '''

    @others
</t>
<t tx="ekr.20101027070126.1662">def run (self):

    '''The top-level logic.'''

    self.clean_spellpyx()
    self.make_manifest()
    files = self.clean_manifest()

    # Compute the list of all the directories.
    dirs = self.directoryList(rootDir)

    # Compute dictionaries of directories and files.
    dirDict,filesDict = self.makeDicts(dirs,files)

    # Print manifest lines not in either dict.
    # This is a crucial check.
    errors = self.printMissing(files,dirDict,filesDict)
    if not errors:
        self.copy_ref_files()
        self.create_install_files(dirs,dirDict,filesDict)
        self.create_uninstall_files(dirs,dirDict,filesDict)
        self.make_zip()
</t>
<t tx="ekr.20101027070126.1663">def directoryList (self,rootDir):

    '''Compute a top-down list of all directories.
       These directories start at the top-level directory.'''

    trace = False
    ignoreDirs = ('.bzr',)
    # Important: this adds all directories on EKR's machine,
    # regardless of whether they appear in the manifest!
    result = [] ; n = len(rootDir)
    for z in os.walk(rootDir): # top-down traversal.
        dirpath, dirnames, filenames = z
        assert dirpath.startswith(rootDir),z
        if len(dirpath) &gt; n:
            path = dirpath[n+1:].replace('\\','/')
            result.append(path)
    for z2 in ignoreDirs:
        result = [ z for z in result if not z.startswith(z2)]
    if trace:
        g.trace('-' * 40)
        g.trace(g.listToString(result))
    return result
</t>
<t tx="ekr.20101027070126.1664">def filterLines (self,lines):

    '''Filter lines from the input manifest file.'''

    trace = False

    # Remove blank lines, comments, and .pyc and .pyo files.
    lines = self.deleteBlankLines(lines)
    lines = self.deleteComments(lines)
    lines = self.deleteTempFiles(lines)
    lines = self.deleteExt(lines,'.pyc')
    lines = self.deleteExt(lines,'.pyo')
    lines = self.deleteExt(lines,'.zip') # Don't include the zip file.
    lines = self.deleteExt(lines,'.exe') # Don't include the installer.

    # Remove specific files.
    deleteList = (
        '.bzrignore',
        'bzr-manifest.txt',
        'bzr-small-manifest.txt',
        'setup.py',
        'leo/test/unittest/.leo_shadow/',
        'nsi.log.txt', # Can't write log while we are creating it.
        'leo/core/leoPy.leo',
        'leo/core/ekrLeoPy.leo',
    )
    lines = self.deleteFiles(lines,deleteList)
    # if lines and lines[0].endswith('bzr ls -R'):
    if lines and lines[0].find('bzr.exe') &gt; -1:
        lines = lines[1:]

    if trace:
        g.trace('=' * 40)
        g.trace(g.listToString(lines))

    return lines
</t>
<t tx="ekr.20101027070126.1665">def deleteBlankLines (self,lines):

    return [z.strip() for z in lines if z.strip()]

def deleteComments (self,lines):

    return [z for z in lines if not z.startswith('#')]

def deleteExt (self,lines,ext):

    return [z for z in lines if not z.endswith(ext)]

def deleteFiles (self,lines,deleteList):

    return [z for z in lines if not z in deleteList]

def deleteTempFiles (self,lines):

    for i in range(1,10):
        lines = [z for z in lines if not z.endswith('~%s~' % i)]
    return lines
</t>
<t tx="ekr.20101027070126.1666">def makeDicts (self,dirs,lines):

    trace = False ; verbose = False

    # Create the dirDict.
    # Keys are directories.
    # Values are files contained in each directory.
    dirDict = {}
    dirDict['**top'] = [] # Create an entry for the root directory.
    for z in dirs:
        dirDict[z] = []

    # Assign files to dirDict.
    for line in lines:
        line = line.strip().replace('\\','/')
        if line in dirDict.keys():
            path,fn = None,None
        elif line.startswith('leo/'):
            path,fn = g.os_path_split(line)
        else:
            path,fn = '**top',line.strip()

        # Don't include top-level leo directory,
        # Do include leo/scripts/leo file.
        if fn and (path != '**top**' or fn != 'leo'):
            aList = dirDict.get(path,[])
            assert line not in aList,repr(line)
            aList.append(fn)
            dirDict[path]=aList

    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        if aList and trace:
            if verbose:
                print() ; print(theDir)
                print(g.listToString(aList))
            else:
                print(theDir)

    # Create the inverse dict.
    filesDict = {}
    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        for fn in aList:
            path = g.choose(theDir=='**top',
                fn,'%s/%s' % (theDir,fn))
            filesDict[path] = theDir

    return dirDict,filesDict
</t>
<t tx="ekr.20101027070126.1667">def printMissing (self,files,dirDict,filesDict):

    errors = 0

    for fn in files:
        fn = fn.rstrip('/')
        if fn and fn not in dirDict and fn not in filesDict:
            g.es_print('missing',fn,color='red')
            errors += 1

    if errors:
        g.es_print('%s errors' % (errors),color='red')

    return errors
</t>
<t tx="ekr.20101027070126.1675">def create_install_files(self,dirs,dirDict,filesDict):

    global install_fn,rootDir
    put = self.put

    self.f = self.openFile(install_fn)
    if not self.f: return

    # Top level
    theDir = '**top'
    put('\n')
    put('; top-level\n')
    put('SetOutPath "$INSTDIR"\n')
    put('SetOverwrite ifnewer\n')
    aList = dirDict.get(theDir,[])
    for fn in aList:
        put('File "%s"\n' % fn)

    for theDir in dirs:
        if theDir != '**top':
            aList = dirDict.get(theDir,[])
            if aList:
                theDir2 = theDir.replace('/','\\').rstrip('\\')
                put('\n')
                put('SetOutPath $INSTDIR\\%s\n' % theDir2)
                for fn in aList:
                    # Fix bug 425369: quote file names.
                    put('File "%s\\%s\\%s"\n' % (
                        rootDir,theDir2,fn))

    self.f.close()
</t>
<t tx="ekr.20101027070126.1676">def create_uninstall_files(self,dirs,dirDict,filesDict):

    def clean(s):
        return s.replace('/','\\')
    put = self.put

    self.f = self.openFile(uninstall_fn)
    if not self.f: return

    # Part 1: Delete top-level files.
    put('\n')
    put('; Uninstall files...\n\n')

    put('SetOutPath $Temp\n')

    # Get the list of top-level files.
    aList = dirDict.get('**top',[])

    # Add some special cases:
    for fn in ('*.pyo','*.pyc',
        'uninst.exe','setup.py','bzr-manifest.txt',
    ):
        if fn not in aList:
            aList.append(fn)

    for fn in aList:
        # Always delete individual files.
        put('Delete "$INSTDIR\\%s"\n' % fn)

    # Part 2: Delete files in lower directories.
    for theDir in dirs:
        if theDir:
            dir2 = clean(theDir)
            aList = dirDict.get(theDir,[])
            if aList:
                put('\n')
                put('Delete "$INSTDIR\\%s\\*.pyc"\n' % (dir2))
                put('Delete "$INSTDIR\\%s\\*.pyo"\n' % (dir2))
                # Delete all files in any __pycache__ subdirectory.
                put('Delete "$INSTDIR\\%s\\__pycache__\\*.pyc"\n' % (dir2))
            for fn in aList:
                put('Delete "$INSTDIR\\%s\\%s"\n' % (dir2,fn))
            

    # Part 3: Delete directories.
    reverseDirs = dirs[:]
    reverseDirs.reverse()
    put('\n')
    put('; Uninstall directories in reverse order\n')
    for theDir in reverseDirs:
        # Delete the directory even if it has files.
        if theDir and theDir != '**top':
            if not theDir.startswith('.bzr'):
                put('RMDir "$INSTDIR\\%s\\__pycache__"\n' % (clean(theDir)))
                put('RMDir "$INSTDIR\\%s"\n' % (clean(theDir)))

    # Delete the op-level folder.
    put('\n')
    put('; Delete the top-level directory.\n')
    put('RMDir "$INSTDIR"\n')

    self.f.close()
</t>
<t tx="ekr.20101027070126.1678">def put (self,s):

    self.f.write(s)
</t>
<t tx="ekr.20101027070126.1679">def openFile (self,fn,mode='w'):

    try:
        f = open(fn,mode)
        return f
    except IOError:
        g.error('can not open',fn)
        return None
</t>
<t tx="ekr.20101027070126.1680"></t>
<t tx="ekr.20101027131034.1490">@color</t>
<t tx="ekr.20101027135430.1492">http://nsis.sourceforge.net/Docs/Modern%20UI%202/Readme.html</t>
<t tx="ekr.20101027135430.1493">http://nsis.sourceforge.net/Docs/Chapter4.html#4.5</t>
<t tx="ekr.20101027160251.1497">http://nsis.sourceforge.net/Docs/nsDialogs/Readme.html</t>
<t tx="ekr.20101027160251.1500"></t>
<t tx="ekr.20101105103524.1491">def make_manifest(self):

    '''Make bzr-manifest.txt.'''
    
    # make-leo-manifest.bat contains the following:
    #   cls
    #   cd c:\leo.repo\trunk
    #   del bzr-manifest.txt
    #   bzr ls -V -R &gt;bzr-manifest.txt
    #   dir bzr-manifest.txt

    commands = (
        (r'c:\Scripts\make-leo-manifest.bat',False),
            # This helper script does all the work.
    )

    for command,shell in commands:
        print('command: %s' % command)
        proc = subprocess.Popen(command,shell=shell) # ,stderr=subprocess.PIPE)
        proc.communicate()  # Wait for the process terminate.
</t>
<t tx="ekr.20101105103524.1493">def make_zip(self):

    for z in (zipFile,zipFile2):
        if exists(z): self.unlink(z)

    commands = (
        r'cd %s' % (rootDir),
        # This commit ensures the proper files are included in the distribution.
        # r'bzr commit -m "commit doc files during make"',
        r'bzr status',
        r'bzr export "%s"' % (zipFile),
        r'bzr export --root="%s" "%s"' % (bzrRoot,zipFile2),
        # r'dir %s' % (rootDir),
    )

    for z in commands:
        print ('command: %s' % z)
        os.system(z)

    # Removed the temporary zip file.
    if exists(zipFile2):
        self.unlink(zipFile2)
</t>
<t tx="ekr.20101105103524.1494">def clean_manifest(self):

    # Create and filter the list of files from the manifest.
    f = open(manifest_fn)
    s = f.read()
    f.close()
    lines = g.splitLines(s)
    lines = self.filterLines(lines)

    # Write the file back.
    f = open(manifest_fn,'w')
    f.write('\n'.join(lines))
    f.close()

    return lines
</t>
<t tx="ekr.20101115090518.1494">Leo 4.8 final                               November 26, 2010

Leo 4.8 final is now available at:
http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.8:
--------------------------

- Leo now uses the simplest possible sentinel lines in external files.
  External files with sentinels now look like Emacs org-mode files.
- Leo Qt gui now supports Drag and Drop.
  This was one of the most frequently requested features.
- Improved abbreviation commands.
  You now define abbreviations in Leo settings nodes, not external files.
- @url nodes may contain url's in body text.
  This allows headlines to contain summaries: very useful.
- Leo now uses PyEnchant to check spelling.
- Leo can now open multiple files from the command line.
- Leo's ancient Tangle and Untangle commands are now deprecated.
  This will help newbies how to learn Leo.
- Leo now shows "Resurrected" and "Recovered" nodes.
  These protect data and show how data have changed.
  These fix several long-standing data-related problems.
- A new "screenshots" plugin for creating slide shows with Leo.
  I used this plugin to create Leo's introductory slide shows.
- Improved autocompletion: Ctrl-space starts a one-time completion.
- A better installer.
- Many bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="ekr.20110603112852.1505">Leo 4.9 final              June 21, 2011

Leo 4.9 final is now available at:
http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
See: http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.9:
--------------------------

- The Qt gui completely replaces the Tk gui--Qt gui now has all essential
  features of Tk, including plugins.

- Completed Leo's autocompleter.

- The rendering pane can now display movies, html, svg images, etc.

- The scrolledmessage plugin can now use the rendering pane.

- Nodes may contain multiple @language directives.

- Leo highlights URL's everywhere. Ctrl-click URL's opens them in your web
  browser. 

- Leo uses an @file node's extension by default if there is no @language
  directive in effect.
  
- Unified extract and import commands.

- Leo can now colorize multiple @language directives in a single node.

- Plain up/down arrow keys in headline-editing mode select a new node.

- New commands to insert, delete, change or print uA's.

- Added namespace directive to .leo files.

- Fixed many bugs, some important, most quite minor.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="ekr.20110603171959.1506">def clean_spellpyx (self):
    
    fn = g.os_path_finalize_join(pluginsDir,'spellpyx.txt')
    f = self.openFile(fn,mode='rb')
    s = f.read()
    f.close()
    s2 = s.replace(b'\r',b'')
    if s != s2:
        g.es_print('cleaning',fn)
        f = self.openFile(fn,mode='wb')
        f.write(s2)
        f.close()
</t>
<t tx="ekr.20110614062644.1378">def copy_ref_files (self):
    
    table = (
        (pluginsDir,'leoGuiPlugins.leo','leoGuiPluginsRef.leo'),
        (pluginsDir,'leoPlugins.leo','leoPluginsRef.leo'),
        (coreDir,'leoPy.leo','leoPyRef.leo'),
    )
    
    for d,src,dst in table:
        src_path = join(d,src)
        dst_path = join(d,dst)
        if not exists(src_path):
            g.error('does not exist',src_path)
        if not exists(dst_path):
            g.error('does not exist',dst_path)
        if exists(src_path) and exists(dst_path):
            shutil.copyfile(src_path,dst_path)
</t>
<t tx="ekr.20110614062644.1379"># Globals...
abspath,exists,join = g.os_path_abspath,g.os_path_exists,g.os_path_join

# First.
bzrRoot     = join('Lib','site-packages','Leo-%s' % (version))
    # Don't use abspath!
distDir     = abspath(join(g.app.loadDir,'..','dist'))
rootDir     = abspath(join(g.app.loadDir,'..','..')) # Same as top.
pluginsDir  = abspath(join(g.app.loadDir,'..','plugins'))

# Next.
coreDir =       abspath(join(g.app.loadDir,'..','core'))
docDir =        abspath(join(g.app.loadDir,'..','doc'))
manifest_fn =   abspath(join(rootDir,'bzr-manifest.txt'))
install_fn =    abspath(join(distDir,'nsi-install-files.txt'))
uninstall_fn =  abspath(join(distDir,'nsi-uninstall-files.txt'))
zipFile =       abspath(join(rootDir,'Leo-%s.zip' % (version)))
zipFile2 =      abspath(join(rootDir,'Leo-%s-temp.zip' % (version)))

# assert g.os_path_exists(manifest)</t>
<t tx="ekr.20120328150744.1791">Leo 4.10 final                                         March 29, 2012

Leo 4.10 final is now available at: http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
http://webpages.charter.net/edreamleo/intro.html

Leo 4.10 contains 9 months of intense work on Leo. Several very important
features are subtle; you could almost call them Easter Eggs, so please read
the following notes carefully.

The highlights of Leo 4.10:
--------------------------

* Dozens of new and improved features and commands, including...
  - Tab completion now shows all @command &amp; @button nodes.
  - Leo tabs may be detached from the main window.
  - The Open With menu now works.
  - The leoInspect module answers questions about Python code.
  - Leo can highlight the pane containing the focus.
  - The bigdash plugin searches across multiple files.
  - Improved abbreviation capabilities.
  - Improved handling of URL's.
  - Improved editing of non-Leo files.
  - Improvements create "weightless" unit testing.
  - Improved Leo's home page.
* Easier installation on MacOS.
* Fixed almost 70 bugs.

The Easter Eggs
---------------

1. Tab completion now shows all @command &amp; @button nodes.

Put all your common scripts in @command nodes in myLeoSettings.leo.
Typing &lt;Alt-X&gt;@c&lt;Tab&gt; will remind you of the names of these scripts.
You can execute the scripts by name without the "@command-" prefix.

2. Improved abbreviation capabilities.

Virtually any kind of abbreviation is possible. For example, ~a to Ã£.

3. Improved handling of URL's.

URL's can be used as links to other Leo outlines.

4 Weightless unit testing.

The mantra is edit, alt-4 (run-marked-unit-tests-externally), edit,
alt-4,... Several seemingly innocuous changes made this work without
"friction". The result is a remarkable increase in productivity.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html
</t>
</tnodes>
</leo_file>
